-->>>>>>>>>>>-------------------------------------------------------------------
-- CLEAR DATABASE.
-->>>>>>>>>>>-------------------------------------------------------------------

DROP PROCEDURE SP_ALL_INSERT;
/

DROP PROCEDURE SP_ALL_UPDATE;
/

DROP PROCEDURE SP_ALL_DELETE;
/

-->>>>>>>>>>>-------------------------------------------------------------------

DROP TRIGGER CHECK_TRANSACTION_BALANCE_tgr;
/

DROP TRIGGER TRANSACTION_trg;
/

DROP SEQUENCE TRANSACTION_seq;
/

DROP TABLE TRANSACTION_;
/

ALTER TABLE TRANSACTION_
DROP PARTITION NOV_2023;
/


ALTER TABLE TRANSACTION_
DROP PARTITION OUT_2023;
/

ALTER TABLE TRANSACTION_
DROP PARTITION ALL_months;
/

-->>>>>>>>>---------------------------------------------------------------------
DROP TABLE DISTRICT_EXT;
/

DROP TABLE MUNICIPALITY_EXT;
/

DROP TABLE POSTCODE_EXT;
/

DROP TABLE TRANSACTIONNAME_EXT;
/

DROP MATERIALIZED VIEW unique_district_mview;
/

DROP MATERIALIZED VIEW transaction_name_mview;
/
DROP MATERIALIZED VIEW MV_ACCOUNT_OWNER;
/
DROP  MATERIALIZED VIEW MV_AGENCY;
/
DROP  MATERIALIZED VIEW MV_CARD_TRANSACTION
/
-->>>>>>>>>>>-------------------------------------------------------------------

ALTER TABLE AGENCY_ DROP COLUMN IdManager;
/

DROP TRIGGER UPDATE_EXPIRATION_CARD;
/

DROP TRIGGER CARD_trg;
/

DROP SEQUENCE CARD_seq;
/

DROP TABLE CARD_;
/

-->>>>>>>>>>>

ALTER TABLE OWNER_ DROP COLUMN nif;
/

DROP TRIGGER OWNER_trg;
/

DROP SEQUENCE OWNER_seq;
/

DROP TABLE OWNER_;
/

-->>>>>>>>>>>

ALTER TABLE ACCOUNT_ DROP COLUMN idAgency;
/

ALTER TABLE ACCOUNT_ DROP COLUMN idAccountType;
/

DROP TRIGGER UPDATE_CREATION_ACCOUNT;
/

DROP TRIGGER ACCOUNT_trg;
/

DROP SEQUENCE ACCOUNT_seq;
/

DROP TABLE ACCOUNT_;
/

-->>>>>>>>>>>

DROP TRIGGER UPDATE_AGE_CLIENT;
/

DROP TABLE CLIENT_;
/

-->>>>>>>>>>>

DROP TRIGGER UPDATE_AGE_EMPLOYEE;
/

DROP TABLE EMPLOYEE_;
/

-->>>>>>>>>>>

DROP TRIGGER AGENCY_trg;
/

DROP SEQUENCE AGENCY_seq;
/

DROP TABLE AGENCY_;
/
-->>>>>>>>>>>-------------------------------------------------------------------

DROP TRIGGER LOCATION_trg;
/

DROP SEQUENCE LOCATION_seq;
/

DROP TABLE LOCATION_;
/

-->>>>>>>>>>>

DROP TRIGGER ACCOUNTTYPE_trg;
/

DROP SEQUENCE ACCOUNTTYPE_seq;
/

DROP TABLE ACCOUNTTYPE_;
/

-->>>>>>>>>>>

DROP TRIGGER TRANSACTIONTYPE_trg;
/

DROP SEQUENCE TRANSACTIONTYPE_seq;
/

DROP TABLE TRANSACTIONTYPE_;
/

-->>>>>>>>>>>-------------------------------------------------------------------

DROP TYPE AddressType;
/

-->>>>>>>>>>>

DROP TYPE ContactType;
/

-->>>>>>>>>>>

DROP TYPE multiObjectFunction;
/
-->>>>>>>>>>>-------------------------------------------------------------------

DROP TABLESPACE STATIC_TABLE_SPACE INCLUDING CONTENTS AND DATAFILES;
/

-->>>>>>>>>>>

DROP TABLESPACE NORMALS_TABLE_SPACE INCLUDING CONTENTS AND DATAFILES;
/

-->>>>>>>>>>>

DROP TABLESPACE TRANSACTION_TABLE_SPACE INCLUDING CONTENTS AND DATAFILES;
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- TYPES Address AND Contact.
-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TYPE 

CREATE TYPE AddressType AS OBJECT ( 
    street VARCHAR(99),
    districtProvince VARCHAR(99),
    country VARCHAR(99)
);
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TYPE 

CREATE TYPE ContactType AS OBJECT ( 
    nin number(3),
    Contact NUMBER(9),
    email VARCHAR(99)
);
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TYPE (Array)

CREATE OR REPLACE TYPE multiObjectFunction AS TABLE OF VARCHAR2(50);
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- TABLESPACE STATIC AND TABLES LOCATION, ACCOUNT TYPE AND TRANSACTION TYPE.
-->>>>>>>>>>>-------------------------------------------------------------------

CREATE TABLESPACE STATIC_TABLE_SPACE
DATAFILE 'static_tablesV2.dbf' SIZE 50M
AUTOEXTEND ON NEXT 5M
MAXSIZE UNLIMITED;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE LOCATION_(
    idLocation NUMBER(9) PRIMARY KEY,
    districtProvince varchar(99),
    country VARCHAR(99)
) PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE LOCATION_ MOVE TABLESPACE STATIC_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE LOCATION_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER LOCATION_trg
BEFORE INSERT ON LOCATION_
FOR EACH ROW
BEGIN
  SELECT LOCATION_seq.NEXTVAL
  INTO :new.idLocation
  FROM dual;
END;
/

ALTER TABLE LOCATION_ MOVE TABLESPACE STATIC_TABLE_SPACE;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_country_location ON LOCATION_(country);

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE ACCOUNTTYPE_(
     idAccountType NUMBER(9) PRIMARY KEY,
     nameAccountType VARCHAR(45),
     description VARCHAR(99),
     minimumRequirements VARCHAR(99)
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE ACCOUNTTYPE_ MOVE TABLESPACE STATIC_TABLE_SPACE;
/
 
-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE ACCOUNTTYPE_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER ACCOUNTTYPE_trg
BEFORE INSERT ON ACCOUNTTYPE_
FOR EACH ROW
BEGIN
  SELECT ACCOUNTTYPE_seq.NEXTVAL
  INTO :new.idAccountType
  FROM dual;
END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_id_name_account_type ON ACCOUNTTYPE_(nameAccountType);

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE TRANSACTIONTYPE_(
     idTransactionType NUMBER(9) PRIMARY KEY,
     nameTransactionType VARCHAR(45),
     description VARCHAR(45),
     appliedRate NUMBER(3),
     LimitTransaction FLOAT
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE TRANSACTIONTYPE_ MOVE TABLESPACE STATIC_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE TRANSACTIONTYPE_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER TRANSACTIONTYPE_trg
BEFORE INSERT ON TRANSACTIONTYPE_
FOR EACH ROW
BEGIN
  SELECT TRANSACTIONTYPE_seq.NEXTVAL
  INTO :new.idTransactionType
  FROM dual;
END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_id_name_transaction_type ON TRANSACTIONTYPE_(nameTransactionType);

-->>>>>>>>>>>-------------------------------------------------------------------
-- TABLESPACE NORMALS AND TABLES AGENCY, EMPLOYEE, CLIENT, ACCOUNT AND CARD.
-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLESPACE

CREATE TABLESPACE NORMALS_TABLE_SPACE
DATAFILE 'regular_tablesV2.dbf' SIZE 50M
AUTOEXTEND ON NEXT 5M
MAXSIZE UNLIMITED;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE AGENCY_(
    idAgency NUMBER(9) PRIMARY KEY,
    nameAgency varchar(45),
    openingHours varchar(45),
    NEmployees number,
    Contact ContactType,
    --forein keyss
    idLocation NUMBER(9),
    FOREIGN KEY (idLocation) REFERENCES LOCATION_(idLocation) ON DELETE SET NULL
    
)PARALLEL;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_id_name_agency ON AGENCY_(nameAgency);

-->>>>>>>>>>>

ALTER TABLE AGENCY_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE AGENCY_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER AGENCY_trg
BEFORE INSERT ON AGENCY_
FOR EACH ROW
BEGIN
  SELECT AGENCY_seq.NEXTVAL
  INTO :new.idAgency
  FROM dual;
END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE EMPLOYEE_(
    nif NUMBER(9) PRIMARY KEY,
    nameEmployee  VARCHAR(45),
    surname VARCHAR(45),
    Contact ContactType,
    address AddressType,
    age number(3),
    dateBirth date,
    iban VARCHAR(99),
    JobRole VARCHAR(45),
    salary NUMBER(20),
    idAgency NUMBER(9),
    CONSTRAINT FK_Employee_AgencyAccount FOREIGN KEY (idAgency) REFERENCES AGENCY_(idAgency) ON DELETE SET NULL
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE EMPLOYEE_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/
-->>>>>>>>>>> INDEX

CREATE INDEX idx_nameEmployee ON EMPLOYEE_(nameEmployee);

CREATE INDEX idx_surname ON EMPLOYEE_(surname);

CREATE INDEX idx_iban ON EMPLOYEE_(iban);

CREATE INDEX idx_idAgency ON EMPLOYEE_(idAgency);

-->>>>>>>>>>>-------------------------------------------------------------------

ALTER TABLE AGENCY_ ADD IdManager NUMBER(9);
/

-->>>>>>>>>>>

ALTER TABLE AGENCY_ ADD FOREIGN KEY (IdManager) REFERENCES EMPLOYEE_(nif);
/

-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER UPDATE_AGE_EMPLOYEE
BEFORE INSERT ON EMPLOYEE_
FOR EACH ROW
BEGIN
  :new.age := TRUNC(MONTHS_BETWEEN(SYSDATE, :new.dateBirth) / 12);
END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE 

CREATE TABLE CLIENT_(
    nif NUMBER(9) PRIMARY KEY,
    nameClient  VARCHAR(45),
    Contact ContactType,
    address AddressType,
    age number(3),
    dateBirth date,
    jobClient Varchar(45),
    maritalStatus VARCHAR(50) CHECK (maritalStatus IN ('SOLTEIRO', 'CASADO')),
    passwordCLient VARCHAR(45),
    idAgency NUMBER(9),
    CONSTRAINT FK_Client_Agency FOREIGN KEY (idAgency) REFERENCES AGENCY_(idAgency) ON DELETE SET NULL
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE CLIENT_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/

-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER UPDATE_AGE_CLIENT
BEFORE INSERT ON CLIENT_
    FOR EACH ROW
BEGIN
  :new.age := TRUNC(MONTHS_BETWEEN(SYSDATE, :new.dateBirth) / 12);
    END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_nameClient ON CLIENT_(nameClient);

CREATE INDEX idx_ClientidAgency ON CLIENT_(idAgency);

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE

CREATE TABLE ACCOUNT_(
    idAccount NUMBER(9) PRIMARY KEY,
    creationDate DATE,
    balance NUMBER(12,2),
    status varchar(10) CHECK (status IN ('congelada', 'normal', 'etc')),
    idAgency NUMBER(9),
    idAccountType NUMBER(9),
    CONSTRAINT FK_AgencyAccount FOREIGN KEY (idAgency) REFERENCES AGENCY_(idAgency)ON DELETE SET NULL,
    CONSTRAINT FK_AcountTypeAccount FOREIGN KEY (idAccountType) REFERENCES ACCOUNTTYPE_(idAccountType)ON DELETE SET NULL

)PARALLEL;
/

ALTER TABLE ACCOUNT_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE ACCOUNT_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER AUTO INCREMENT

CREATE OR REPLACE TRIGGER ACCOUNT_trg
BEFORE INSERT ON ACCOUNT_
FOR EACH ROW
BEGIN
  SELECT ACCOUNT_seq.NEXTVAL
  INTO :new.idAccount
  FROM dual;
END;
/

-->>>>>>>>>>> TRIGGER UPDATE CREATION

CREATE OR REPLACE TRIGGER UPDATE_CREATION_ACCOUNT
BEFORE INSERT ON ACCOUNT_
FOR EACH ROW
BEGIN
  :new.creationDate := TO_DATE(SYSDATE, 'YYYY-MM-DD HH24:MI:SS');
END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_idAccountType ON ACCOUNT_(idAccountType);

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE

CREATE TABLE CARD_(
    idCard NUMBER(9) PRIMARY KEY,
    expirationDate DATE,
    pin number(4),
    CVC number(3),
    cardType varchar(45) CHECK (cardType IN ('Debito', 'Credito')),
    idAccount NUMBER(9),
    CONSTRAINT FK_AcountCard FOREIGN KEY (idAccount) REFERENCES ACCOUNT_(idAccount) ON DELETE SET NULL
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE CARD_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE CARD_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER CARD_trg
BEFORE INSERT ON CARD_
FOR EACH ROW
BEGIN
  SELECT CARD_seq.NEXTVAL
  INTO :new.idCard
  FROM dual;
END;
/

-->>>>>>>>>>> TRIGGER UPDATE EXPIRATION

CREATE OR REPLACE TRIGGER UPDATE_EXPIRATION_CARD
BEFORE INSERT ON CARD_
FOR EACH ROW
BEGIN
  :new.expirationDate := SYSDATE - INTERVAL '5' YEAR;
END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_idAccount ON CARD_(idAccount);

-->>>>>>>>>>>-------------------------------------------------------------------

CREATE TABLE OWNER_ (  
    idOwner NUMBER(9) PRIMARY KEY,
    idAccount NUMBER(9),
    nif NUMBER(9), 
    ownership NUMBER(1) CHECK (ownership IN (1, 2)), -- 1 for main owner, 2 for secondary owner
    CONSTRAINT FK_Owners_Account FOREIGN KEY (idAccount) REFERENCES ACCOUNT_(idAccount) ON DELETE SET NULL,
    CONSTRAINT FK_Owners_Client FOREIGN KEY (nif) REFERENCES CLIENT_(nif) ON DELETE SET NULL,
    CONSTRAINT UQ_MainOwner UNIQUE (idAccount, ownership) -- Unique constraint to ensure only one main owner per account
) PARALLEL;
/
ALTER TABLE OWNER_ MOVE TABLESPACE NORMALS_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE OWNER_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER OWNER_trg
BEFORE INSERT ON OWNER_
FOR EACH ROW
BEGIN
  SELECT OWNER_seq.NEXTVAL
  INTO :new.idOwner
  FROM dual;
END;
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_Owner_idAccount ON OWNER_(idAccount);

CREATE INDEX idx_nif ON OWNER_(nif);

-->>>>>>>>>>>-------------------------------------------------------------------
-- TABLESPACE AND TABLE TRANSACTION.
-->>>>>>>>>>>-------------------------------------------------------------------

CREATE TABLESPACE TRANSACTION_TABLE_SPACE
DATAFILE 'transactionV2.dbf' SIZE 100M
AUTOEXTEND ON NEXT 10M
MAXSIZE UNLIMITED;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> CREATE TABLE

CREATE TABLE TRANSACTION_(
     idTransaction NUMBER(10) PRIMARY KEY,
     amount NUMBER(12,2),
     dateTransaction date,
     nameTransaction VARCHAR(45),
     status varchar(11) CHECK (status IN ('processando', 'concluido', 'etc')),
     idCard NUMBER(9),
     idTransactionType NUMBER(9),
     idAccount NUMBER(9),
     idOwner NUMBER(9),
     idRecipient_Account NUMBER(9),
    CONSTRAINT FK_Transaction_AcountCard FOREIGN KEY (idCard) REFERENCES CARD_(idCard) ON DELETE SET NULL,
    CONSTRAINT FK_TransactionType FOREIGN KEY (idTransactionType) REFERENCES TRANSACTIONTYPE_(idTransactionType) ON DELETE SET NULL,
    CONSTRAINT FK_Transaction_Account FOREIGN KEY (idAccount) REFERENCES ACCOUNT_(idAccount) ON DELETE SET NULL,
    CONSTRAINT FK_Card_Owner FOREIGN KEY (idOwner) REFERENCES OWNER_(idOwner) ON DELETE SET NULL,
    CONSTRAINT FK_Transaction_Recipient FOREIGN KEY (idRecipient_Account) REFERENCES ACCOUNT_(idAccount) ON DELETE SET NULL,
    CONSTRAINT CHK_TypeBtwnTwoAcc CHECK (NOT (idTransactionType = 5 AND idRecipient_Account IS NULL)), -- se for entre duas contas, o idrecipient não pode ser nulo
    CONSTRAINT CHK_DIFTypeTwoAcc CHECK (NOT (idTransactionType <> 5 AND idRecipient_Account IS NOT NULL)), --se nao for entre duas contas, o idrecipient tem que ser nulo
    CONSTRAINT CHK_AccDIFRecip CHECK (NOT (idAccount = idRecipient_Account)), --na transacao entre duas contas, o id da account nao pode ser igual ao do recepiente. Nao faz sentido.
    CONSTRAINT CHK_Type5Not CHECK (NOT (idTransactionType = 5 AND amount <= 0)) --na transacao entre duas contas, o valor nao pode ser negativo. Nao se pode tirar dinheiro de outra conta
)PARALLEL;
/

-->>>>>>>>>>>

ALTER TABLE TRANSACTION_ MOVE TABLESPACE TRANSACTION_TABLE_SPACE;
/

-->>>>>>>>>>> SEQUENCE

CREATE SEQUENCE TRANSACTION_seq
  START WITH 1
  INCREMENT BY 1;
/
 
-->>>>>>>>>>> TRIGGER

CREATE OR REPLACE TRIGGER CHECK_TRANSACTION_BALANCE_tgr ---> verifica se o montante numa transacao nao vai dar em valor negativo (i.e, ficar em dívida XD)
BEFORE INSERT ON TRANSACTION_
FOR EACH ROW
DECLARE
    account_balance NUMBER(12,2);
BEGIN
 
    SELECT balance INTO account_balance FROM ACCOUNT_ WHERE idAccount = :NEW.idAccount;
 
 
    IF account_balance + :NEW.amount < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'The amount on the withdrawl cant be bigger than the balance on the account. Please insert values that are smaller than ' || -:NEW.amount || '€');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER TRANSACTION_trg
BEFORE INSERT ON TRANSACTION_
FOR EACH ROW
BEGIN
  SELECT TRANSACTION_seq.NEXTVAL
  INTO :new.idTransaction
  FROM dual;
END;
/

-->>>>>>>>>>> TRIGGER UPDATE EXPIRATION
CREATE OR REPLACE TRIGGER UPDATE_DATE_TRANSACTION
BEFORE INSERT ON TRANSACTION_
FOR EACH ROW
BEGIN
  :new.dateTransaction := SYSDATE;
END;
/

-->>>>>>>>>>> TRANSACTION_ PARTITION BY RANGE MES
CREATE TABLE
TRANSACTION_partition (idTransaction NUMBER(9), amount NUMBER(12), dateTransaction DATE, nameTransaction VARCHAR2(45), status VARCHAR2(11), idCard NUMBER(9), idTransactionType NUMBER(9), idAccount NUMBER(9), idOwner NUMBER(9))
PARTITION BY RANGE (dateTransaction) (
PARTITION
OUT_2023 VALUES LESS THAN (TO_DATE('30 10 2023','dd mm yyyy')) TABLESPACE TRANSACTION_TABLE_SPACE,
PARTITION
NOV_2023 VALUES LESS THAN (TO_DATE('30 11 2023','dd mm yyyy')) TABLESPACE TRANSACTION_TABLE_SPACE,
PARTITION
ALL_months VALUES LESS THAN (MAXVALUE) TABLESPACE TRANSACTION_TABLE_SPACE
);
/

-->>>>>>>>>>> INDEX

CREATE INDEX idx_idCard ON TRANSACTION_(idCard);
/

CREATE INDEX idx_idTransactionType ON TRANSACTION_(idTransactionType);
/

CREATE INDEX idx_Transaction_idAccount ON TRANSACTION_(idAccount);
/

CREATE INDEX idx_idOwner ON TRANSACTION_(idOwner);
/


-->>>>>>>>>>>-------------------------------------------------------------------
-- EXTERNAL TABLES
-->>>>>>>>>>>-------------------------------------------------------------------
--DIRECTORY FOR EXTERNAL TABLES
BEGIN
    EXECUTE IMMEDIATE 'CREATE OR REPLACE DIRECTORY Location_Directory  as ''/home/oracle/src/location_files'''; -- MUDAR CONFORME ONDE ESTÃO OS FICHEIROS EXCEL
END;
/

-->>>>>>>>>>> TRANSACTION NAME
CREATE TABLE TRANSACTIONNAME_EXT
(
    id_transaction_name NUMBER (9),
    TransactionName VARCHAR(45)
)
ORGANIZATION EXTERNAL(
TYPE ORACLE_LOADER
DEFAULT DIRECTORY Location_Directory
Access parameters (
RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ';'
)
LOCATION('TransactionNames.csv')
);

-->>>>>>>>>>> DISTRITO
CREATE TABLE DISTRICT_EXT
(
    id_district NUMBER (25),
    name VARCHAR(25)
    
)
ORGANIZATION EXTERNAL(
TYPE ORACLE_LOADER
DEFAULT DIRECTORY Location_Directory
Access parameters (
RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ';'
)
LOCATION('DISTRICT.csv')
);
-->>>>>>>>>>>>>MUNICIPIO
CREATE TABLE MUNICIPALITY_EXT
(
    id_district NUMBER (25),
    id_municipality NUMBER(25),
    municipality_name VARCHAR(45)
    
)
ORGANIZATION EXTERNAL(
TYPE ORACLE_LOADER
DEFAULT DIRECTORY Location_Directory
Access parameters (
RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ';'
)
LOCATION('MUNICIPALITY.csv')
);
-->>>>>>>>>>>>>>>>>CODIGO POSTAL
CREATE TABLE POSTCODE_EXT
(
    id_district NUMBER (25),
    id_municipality NUMBER(25),
    id_postcode NUMBER(25),
    city VARCHAR(45)
    
)
ORGANIZATION EXTERNAL(
TYPE ORACLE_LOADER
DEFAULT DIRECTORY Location_Directory
Access parameters (
RECORDS DELIMITED BY NEWLINE
FIELDS TERMINATED BY ';'
)
LOCATION('POSTCODE.csv')
);

CREATE MATERIALIZED VIEW MV_AGENCY
TABLESPACE STATIC_TABLE_SPACE
BUILD IMMEDIATE
REFRESH COMPLETE
AS
SELECT idAgency, nameAgency, openingHours, NEmployees, Contact, idLocation
FROM AGENCY_;
----
CREATE MATERIALIZED VIEW MV_ACCOUNT_OWNER
TABLESPACE NORMALS_TABLE_SPACE
BUILD IMMEDIATE
REFRESH COMPLETE
AS
SELECT A.idAccount, A.creationDate, A.balance, A.status, A.idAgency, A.idAccountType, O.nif as owner_nif
FROM ACCOUNT_ A
LEFT JOIN OWNER_ O ON A.idAccount = O.idAccount;

----
CREATE MATERIALIZED VIEW MV_CARD_TRANSACTION
TABLESPACE TRANSACTION_TABLE_SPACE
BUILD IMMEDIATE
REFRESH COMPLETE
AS
SELECT C.idCard, C.expirationDate, C.cardType, T.idTransaction, T.amount, T.dateTransaction
FROM CARD_ C
LEFT JOIN TRANSACTION_ T ON C.idCard = T.idCard;

-->>>>>>>>>>>>>>>>unique_district_mview
CREATE MATERIALIZED VIEW unique_district_mview
TABLESPACE STATIC_TABLE_SPACE
BUILD IMMEDIATE
REFRESH COMPLETE
AS
SELECT 
    d.name AS district_name,
    m.municipality_name,
    p.id_postcode,
    p.city
FROM
    DISTRICT_EXT d
    JOIN MUNICIPALITY_EXT m ON d.id_district = m.id_district
    JOIN POSTCODE_EXT p ON m.id_municipality = p.id_municipality
ORDER BY
    d.id_district;
    
BEGIN
    EXECUTE IMMEDIATE 'SELECT * FROM unique_district_mview'; -- MUDAR CONFORME ONDE ESTÃO OS FICHEIROS EXCEL
END;
/

-->>>>>>>>>>>>>>transaction_name_mview
BEGIN
    EXECUTE IMMEDIATE '
CREATE MATERIALIZED VIEW Transaction_name_mview
TABLESPACE STATIC_TABLE_SPACE
BUILD IMMEDIATE
REFRESH COMPLETE
AS
SELECT 
    TransactionName,
    id_transaction_name
FROM TRANSACTIONNAME_EXT';

END;
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- COMMENTS.
-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> LOCATION_

COMMENT ON TABLE LOCATION_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre localizações, incluindo ID da localização, distrito/província 
e país.';
/

-->>>>>>>>>>> ACCOUNTTYPE

COMMENT ON TABLE ACCOUNTTYPE_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre tipos de conta, incluindo ID do tipo de conta, nome, 
descrição e requisitos mínimos.';
/

-->>>>>>>>>>> TRANSACTIONTYPE

COMMENT ON TABLE TRANSACTIONTYPE_ IS 'Esta tabela destina-se ao armazenamento 
de informações sobre tipos de transação, incluindo ID do tipo de transação, 
nome, descrição, taxa aplicada e limite.';
/

-->>>>>>>>>>> AGENCY

COMMENT ON TABLE AGENCY_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre agências, incluindo ID da agência, nome da agência, horário 
de funcionamento, número de funcionários, detalhes de contato e ID de 
localização referente à tabela LOCATION_.';
/

-->>>>>>>>>>> EMPLOYEE

COMMENT ON TABLE EMPLOYEE_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre funcionários, incluindo NIF, nome do funcionário, sobrenome, 
detalhes de contato, endereço, idade, data de nascimento, IBAN, cargo e 
salário.';
/

-->>>>>>>>>>> CLIENT

COMMENT ON TABLE CLIENT_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre clientes, incluindo NIF, nome do cliente, detalhes de contato, 
endereço, idade, data de nascimento, profissão, estado civil e 
palavra-passe.';
/

-->>>>>>>>>>> ACCOUNT

COMMENT ON TABLE ACCOUNT_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre contas, incluindo ID da conta, quando foi criada, saldo e 
estado.';
/

-->>>>>>>>>>> CARD

COMMENT ON TABLE CARD_ IS 'Esta tabela destina-se ao armazenamento de 
informações sobre cartões, incluindo ID do cartão, data de validade, PIN, 
CVC e tipo de cartão.';
/

-->>>>>>>>>>> TRANSACTION

COMMENT ON TABLE TRANSACTION_ IS 'Esta tabela destina-se ao armazenamento dos 
dados sobre uma transação, efetuada ou não, com dados sobre o montante, estado 
e data de início da transação.';
/
-->>>>>>>>>>> OWNER
COMMENT ON TABLE OWNER_ IS 'Esta tabela destina-se ao armazenamento dos
 dados sobre os proprietários das contas, incluindo informações sobre a 
 relação de propriedade, associada ao número de identificação fiscal (NIF).';
 /

-->>>>>>>>>>>-------------------------------------------------------------------
-- INSERTS.
-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> LOCATION

INSERT /*+ APPEND PARALLEL */ ALL
    INTO LOCATION_ (districtProvince, country) VALUES ('Aveiro', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Beja', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Braga', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Bragança', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Porto', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Santarém', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Setúbal', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Viana do Castelo', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Vila Real', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Viseu', 'Portugal')
    INTO LOCATION_ (districtProvince, country) VALUES ('Ontario', 'Canada')
    INTO LOCATION_ (districtProvince, country) VALUES ('California', 'USA')
    INTO LOCATION_ (districtProvince, country) VALUES ('Queensland', 'Australia')
    INTO LOCATION_ (districtProvince, country) VALUES ('Gauteng', 'South Africa')
    INTO LOCATION_ (districtProvince, country) VALUES ('Kanto', 'Japan')
    INTO LOCATION_ (districtProvince, country) VALUES ('Buenos Aires', 'Argentina')
    INTO LOCATION_ (districtProvince, country) VALUES ('Lombardy', 'Italy')
    INTO LOCATION_ (districtProvince, country) VALUES ('Catalonia', 'Spain')
    INTO LOCATION_ (districtProvince, country) VALUES ('São Paulo', 'Brazil')
    -- Add more INTO clauses as needed for additional provinces
SELECT * FROM dual;


-->>>>>>>>>>> ACCOUNTTYPE

INSERT /*+ APPEND PARALLEL */ ALL
    INTO ACCOUNTTYPE_ (nameAccountType, description, minimumRequirements) VALUES ('Conta-Poupaça', 'Conta para poupar dinhero', 'null')
    INTO ACCOUNTTYPE_ (nameAccountType, description, minimumRequirements) VALUES ('Conta à ordem', 'Não tem produtos ou serviços específicos associados.', '>=18')
    INTO ACCOUNTTYPE_ (nameAccountType, description, minimumRequirements) VALUES ('Conta jovem', 'Conta para Jovens Adolescente', '>=18 e <=25')
    INTO ACCOUNTTYPE_ (nameAccountType, description, minimumRequirements) VALUES ('Conta Ordenado', 'Conta para onde vai parar o seu Oerdenado', '>=18')
    -- Add more INTO clauses as needed for additional rows
SELECT * FROM dual;
/

-->>>>>>>>>>> TRANSACTIONTYPE

INSERT /*+ APPEND PARALLEL */ ALL
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('ATM_nacional', 'transferencia num atm nacional', 0, 400)
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('ATM_internacional', 'Transferencia num atm internacional', 3, 400)
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('ATM_Cambio', 'Cambio ', 5, 400)
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('Cheque', 'Deposito ou levantamento por cheque', 1, 600)
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('Transferencia_de_fundos', 'Transferencia de uma conta para outra', 0.5, 1000000)
    INTO TRANSACTIONTYPE_ (nameTransactionType, description, appliedRate, LimitTransaction) 
    VALUES ('Cartao', 'Transacao por cartao', 0, 1)
SELECT * FROM dual;
/

-->>>>>>>>>>> AGENCY

INSERT /*+ APPEND PARALLEL */ ALL
    INTO AGENCY_ (nameAgency, openingHours, NEmployees, idLocation) 
    VALUES ('Agencia Solverde', '9:00 - 16:00', 3, 1)
    INTO AGENCY_ (nameAgency, openingHours, NEmployees, idLocation) 
    VALUES ('Agencia Betano', '8:30 - 15:30', 3, 2)
    INTO AGENCY_ (nameAgency, openingHours, NEmployees, idLocation) 
    VALUES ('Agencia Betclick', '10:00 - 17:00', 3, 3)
    INTO AGENCY_ (nameAgency, openingHours, NEmployees, idLocation) 
    VALUES ('Agencia Vamos Apostar', '9:30 - 17:00', 3, 4)
    -- Add more INTO clauses as needed for additional agencies
SELECT * FROM dual;
/

-->>>>>>>>>>> EMPLOYEE

INSERT /*+ APPEND PARALLEL */ ALL
    INTO EMPLOYEE_ (nif, nameEmployee, surname, Contact, address, age, dateBirth, iban, JobRole, salary, idAgency) 
    VALUES (123456789, 'Pedro', 'Gonçalves', ContactType(111, 111111111, 'pedro@gmail.com'), AddressType('Rua Marmelo', 'Faro', 'Portugal'), 20, TO_DATE('2003-06-26', 'YYYY-MM-DD'), 'ABC123456789', 'Gerente', 10000, 1)
    INTO EMPLOYEE_ (nif, nameEmployee, surname, Contact,  address, age, dateBirth, iban, JobRole, salary, idAgency) 
    VALUES (987654321, 'Ricardo', 'Vilhena', ContactType(222, 222222222, 'ricardo@gmail.com'), AddressType('Rua MeM', 'Braga', 'Portugal'), 18, TO_DATE('2004-12-18', 'YYYY-MM-DD'), 'DEF987654321', 'Chefe Markting', 7500, 2)
    INTO EMPLOYEE_ (nif, nameEmployee, surname, Contact, address, age, dateBirth, iban, JobRole, salary, idAgency) 
    VALUES (234567230, ';Marco', 'Valente',ContactType(333, 33333333, 'marco@gmail.com'), AddressType('Rua Vodka', 'LIsboa', 'Portugal'), 21, TO_DATE('2002-06-06', 'YYYY-MM-DD'), 'GHI234567890', 'Chefe Designe ', 8000, 1)
    INTO EMPLOYEE_ (nif, nameEmployee, surname, Contact, address, age, dateBirth, iban, JobRole, salary, idAgency) 
    VALUES (234567890, ';Rodrigo', 'Pimenta',ContactType(444, 444444444, 'rodrigo@gmail.com'), AddressType('Rua Getto', 'Coimbra', 'Portugal'), 20, TO_DATE('2003-06-15', 'YYYY-MM-DD'), 'GHI234567890', 'Rececionista', 2000, 3)
    INTO EMPLOYEE_ (nif, nameEmployee, surname, Contact, address, age, dateBirth, iban, JobRole, salary, idAgency) 
    VALUES (234127890, ';Lucas', 'Martins',ContactType(555, 555555555, 'lucas@gmail.com'), AddressType('Rua Ginasio', 'Beja', 'Portugal'), 20, TO_DATE('2003-08-16', 'YYYY-MM-DD'), 'GHI234567890', 'Homem das Limpezas ', 1000, 2)
        -- Add more INTO clauses as needed for additional employees
SELECT * FROM dual;
/

-->>>>>>>>>>> CLIENT

INSERT /*+ APPEND PARALLEL */ ALL
    INTO CLIENT_ (nif, nameClient, address, age, dateBirth, jobClient, maritalStatus, passwordCLient, idAgency) 
    VALUES (123456789, 'Alice', addressType('Rua Ola', 'Faro', 'Portugal'), 28, TO_DATE('1995-03-15', 'YYYY-MM-DD'), 'Engenheiro', 'CASADO', 'alice123', 1)
    INTO CLIENT_ (nif, nameClient, address, age, dateBirth, jobClient, maritalStatus, passwordCLient, idAgency) 
    VALUES (987654321, 'Bob', addressType('456 Oak St', 'Braga', 'Portugal'), 32, TO_DATE('1990-11-20', 'YYYY-MM-DD'), 'Professor', 'SOLTEIRO', 'bob456', 2)
    INTO CLIENT_ (nif, nameClient, address, age, dateBirth, jobClient, maritalStatus, passwordCLient, idAgency) 
    VALUES (234567890, 'Charlie', addressType('789 Maple St', 'LIsboa', 'Portugal'), 24, TO_DATE('1998-06-10', 'YYYY-MM-DD'), 'Designer', 'SOLTEIRO', 'charlie789', 1)
    -- Add more INTO clauses as needed for additional clients
SELECT * FROM dual;
/

-->>>>>>>>>>> ACCOUNT

INSERT /*+ APPEND PARALLEL */ ALL
    INTO ACCOUNT_ (creationDate, balance, status,idAgency, idAccountType) 
    VALUES (TO_DATE('2023-01-15', 'YYYY-MM-DD'), 5000.00, 'normal', 1, 1)
    INTO ACCOUNT_ (creationDate, balance, status,idAgency, idAccountType) 
    VALUES (TO_DATE('2023-02-20', 'YYYY-MM-DD'), 7000.00, 'congelada',2, 2)
    INTO ACCOUNT_ (creationDate, balance, status,idAgency, idAccountType) 
    VALUES (TO_DATE('2023-03-10', 'YYYY-MM-DD'), 3000.00, 'normal',1, 3)
    -- Add more INTO clauses as needed for additional accounts
SELECT * FROM dual;
/

-->>>>>>>>>>> CARD

INSERT /*+ APPEND PARALLEL */ ALL
    INTO CARD_ (pin, CVC, cardTYpe, idAccount) 
    VALUES (1283, 789, 'Debito', 1)
    INTO CARD_ (pin, CVC, cardTYpe, idAccount) 
    VALUES (5678, 456, 'Credito', 2)
    INTO CARD_ (pin, CVC, cardTYpe, idAccount) 
    VALUES (9868, 123, 'Debito', 3)
    -- Add more INTO clauses as needed for additional cards
SELECT * FROM dual;
/

-->>>>>>>>>>> OWNER

INSERT /*+ APPEND PARALLEL */ ALL
    INTO OWNER_ (idAccount, nif, ownership) 
    VALUES (1, 123456789, 1)
    INTO OWNER_ (idAccount, nif, ownership) 
    VALUES (2, 987654321, 2)
    INTO OWNER_ (idAccount, nif, ownership) 
    VALUES (3, 234567890, 1)
    -- Add more INTO clauses as needed for additional owner records
SELECT * FROM dual;
/

-->>>>>>>>>>> TRANSACTION AUTOMATIC AND RANDOM

CREATE OR REPLACE PROCEDURE InsertRandomTransactions AS
  v_num_rows NUMBER := 5;
  v_name_transaction VARCHAR2(45);
  v_idconta NUMBER;
  v_idcard NUMBER;
  v_idowner NUMBER;
  v_idTransactionType NUMBER;
  v_Moneylimit NUMBER;
BEGIN
  FOR i IN 1..v_num_rows LOOP
    -- GUARDAR VALOR RANDOM DE ID CONTA E GUARDAR VALOR DO PRIMEIRO CARTAO ASSOCIADO A ESSA CONTA
    SELECT C.IDACCOUNT INTO v_idconta FROM (SELECT * FROM ACCOUNT_ ORDER BY dbms_random.value) C WHERE rownum = 1;
    SELECT C.idcard INTO v_idcard FROM (SELECT * FROM CARD_ WHERE idcard = v_idconta ORDER BY dbms_random.value) C WHERE ROWNUM <= 1;
    SELECT C.idowner INTO v_idowner FROM (SELECT * FROM OWNER_ where IDOWNER = v_idconta ORDER BY dbms_random.value) C WHERE ROWNUM <= 1;
    
    -- GUARDAR VALOR PARA NOME DA TRANSACAO
    SELECT C.TransactionName INTO v_name_transaction FROM (SELECT * FROM Transaction_name_mview ORDER BY dbms_random.value) C WHERE rownum = 1;
    
    --CONFORME LIMITE DO TIPO DE TRANSACAO CRIAR VARIAVEL COM LIMITE
    SELECT C.idTransactionType INTO v_idTransactionType FROM (SELECT * FROM TRANSACTIONTYPE_ ORDER BY dbms_random.value) C WHERE rownum = 1;
    SELECT C.limittransaction INTO v_MoneyLimit FROM TRANSACTIONTYPE_ C WHERE idTransactionType = v_idTransactionType;
    
    INSERT INTO TRANSACTION_ (idTransaction, amount, dateTransaction, nameTransaction, status, idCard, idTransactionType, idAccount, idOwner)
    VALUES (
      NULL, -- auto increment
      FLOOR(DBMS_RANDOM.value * v_MoneyLimit) + 1, -- amount
      TO_DATE('01-JAN-2020', 'DD-MON-YYYY') + DBMS_RANDOM.value * (TO_DATE('01-DEC-2023', 'DD-MON-YYYY') - TO_DATE('01-JAN-2020', 'DD-MON-YYYY')), -- date da Transaction
      v_name_transaction, -- transaction name
      CASE WHEN DBMS_RANDOM.value < 0.5 THEN 'processando' ELSE 'concluido' END, -- status
      v_idcard, -- card id
      v_idTransactionType, -- id transaction type
      v_idconta, -- id account
      v_idowner -- id owner
    );
  END LOOP;
  COMMIT;
END InsertRandomTransactions;
/


BEGIN
  InsertRandomTransactions;
END;
/

-->>>>>>>>>>> TRANSACTION

-- Inserting multiple rows into the TRANSACTION_ table
--We have de default on this table so the sequence can be triggerd
INSERT /*+ APPEND PARALLEL */ ALL
    INTO TRANSACTION_ (idTransaction, amount, dateTransaction, status, nameTransaction, idCard, idTransactionType, idAccount, idOwner)
    VALUES (DEFAULT, '100.00', TO_DATE('2023-10-18', 'YYYY-MM-DD'), 'concluido', 'salario', 1, 1 ,1 ,1)
    INTO TRANSACTION_ (idTransaction, amount, dateTransaction, status, nameTransaction, idCard, idTransactionType, idAccount, idOwner)
    VALUES (DEFAULT, '200.00', TO_DATE('2023-10-19', 'YYYY-MM-DD'), 'processando', 'salario', 2, 2, 2, 2)
    INTO TRANSACTION_ (idTransaction, amount, dateTransaction, status, nameTransaction, idCard, idTransactionType, idAccount, idOwner)
    VALUES (DEFAULT, '150.00', TO_DATE('2023-10-20', 'YYYY-MM-DD'), 'concluido', 'salario', 3, 3, 3, 3)
SELECT * FROM DUAL;
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- VIEWS.
-->>>>>>>>>>>-------------------------------------------------------------------

-->>>>>>>>>>> LOCATION
--Show locations that aren't in Portugal
CREATE OR REPLACE VIEW location_not_portugal AS 
SELECT idLocation, districtProvince, country
FROM LOCATION_
WHERE country <> 'Portugal';
/
--Show locations that are in Portugal
CREATE OR REPLACE VIEW location_portugal AS 
SELECT idLocation, districtProvince, country
FROM LOCATION_
WHERE country = 'Portugal';
/
--Show What Location Have Agencys
CREATE OR REPLACE VIEW LocationAgency AS
SELECT
    L.idLocation,
    L.districtProvince AS Location_District,
    A.nameAgency AS Agency_Name
FROM LOCATION_ L
JOIN AGENCY_ A ON L.idLocation = A.idLocation;
/

-->>>>>>>>>>> ACCOUNTTYPE~
--Show AccountTypes Description
CREATE OR REPLACE VIEW AccountTypeDescription AS
SELECT
    nameAccountType AS Account_Type,
    description AS Description
FROM ACCOUNTTYPE_;
/


-->>>>>>>>>>> TRANSACTIONTYPE
CREATE OR REPLACE VIEW TransactionTypeStat AS
SELECT
    TT.nameTransactionType AS TransactionTypeName,
    COUNT(T.idTransaction) AS TransactionCount,
    SUM(T.amount) AS TotalAmount
FROM TRANSACTIONTYPE_ TT
LEFT JOIN TRANSACTION_ T ON TT.idTransactionType = T.idTransactionType
GROUP BY TT.nameTransactionType
ORDER BY TT.nameTransactionType;
/


-->>>>>>>>>>> AGENCY
--Show Average Age by Agency
CREATE OR REPLACE VIEW AverageEmployeeAgeByAgency AS
SELECT
    A.nameAgency AS Agency_Name,
    AVG(E.age) AS AverageAge
FROM EMPLOYEE_ E
JOIN AGENCY_ A ON E.idAgency = A.idAgency
GROUP BY A.nameAgency;
/


-->>>>>>>>>>> EMPLOYEE
--Show Witch Emplyee is in wtch Agency
CREATE OR REPLACE VIEW EmployeeWithAgency AS
SELECT
    E.nif AS Employee_NIF,
    E.nameEmployee AS Employee_Name,
    E.surname AS Employee_Surname,
    TREAT(E.Contact AS ContactType).nin AS nin, 
    TREAT(E.Contact AS ContactType).Contact AS Contact, 
    TREAT(E.Contact AS ContactType).email AS email, 
    E.age AS Employee_Age,
    E.JobRole AS Employee_JobRole,
    A.nameAgency AS Agency_Name
FROM EMPLOYEE_ E
JOIN AGENCY_ A ON E.idAgency = A.idAgency;
/
--Show How many Emplyee does the agency have
CREATE OR REPLACE VIEW AgenciesWithEmployeeCount AS
SELECT
    A.idAgency AS Agency_ID,
    A.nameAgency AS Agency_Name,
    COUNT(E.nif) AS EmployeeCount
FROM AGENCY_ A
LEFT JOIN EMPLOYEE_ E ON A.idAgency = E.idAgency
GROUP BY A.idAgency, A.nameAgency;
/

-->>>>>>>>>>> CLIENT
--Show Max and Min of the all time balance of the account
CREATE OR REPLACE VIEW ClientAccountBalanceStats AS
SELECT
    C.nif AS Client_NIF,
    C.nameClient AS Client_Name,
    MIN(A.balance) AS MinBalance,
    MAX(A.balance) AS MaxBalance,
    SUM(A.balance) AS TotalBalance
FROM CLIENT_ C
LEFT JOIN OWNER_ O ON C.nif = O.nif
LEFT JOIN ACCOUNT_ A ON O.idAccount = A.idAccount
GROUP BY C.nif, C.nameClient;
/



-->>>>>>>>>>> ACCOUNT
--Show account / idagency / acctype
CREATE OR REPLACE VIEW ShowAccountIdAgencyAcctype AS
SELECT
    A.idAccount,
    A.creationDate,
    A.idAgency,
    AT.nameAccountType AS Account_Type
FROM ACCOUNT_ A
JOIN ACCOUNTTYPE_ AT ON A.idAccountType = AT.idAccountType
WHERE A.idAgency = 1;
/
--Show AccountHighestBalanceAgency
--RANK() function in SQL is a window function that assigns a unique rank to each row; This assigns a rank to each account within the agency. 
--PARTITION BY clause ensures that ranking is done separately for each agency
--CTE(RankedAccounts) is a temporary result set that is used within the main query.
CREATE OR REPLACE VIEW AccountHighestBalanceAgency AS
WITH RankedAccounts AS (
    SELECT
        A.idAccount AS AccountID,
        A.balance AS HighestBalance,
        A.idAgency AS AgencyID,
        AG.nameAgency AS AgencyName,
        C.nameClient AS ClientName,
        RANK() OVER (PARTITION BY A.idAgency ORDER BY A.balance DESC) AS BalanceRank
    FROM ACCOUNT_ A
    JOIN CLIENT_ C ON A.idAgency = C.idAgency
    JOIN AGENCY_ AG ON A.idAgency = AG.idAgency
)
SELECT
    AccountID,
    HighestBalance,
    AgencyID,
    ClientName,
    AgencyName
FROM RankedAccounts
WHERE BalanceRank = 1;
/

-->>>>>>>>>>> CARD
-- Show only cardType Debito
CREATE OR REPLACE VIEW debit_card_view AS
SELECT idCard, expirationDate, pin, CVC, cardType, idAccount
FROM CARD_
WHERE cardType = 'Debito';
/
-- Show only cardType Credito
CREATE OR REPLACE VIEW credit_card_view AS
SELECT idCard, expirationDate, pin, CVC, cardType, idAccount
FROM CARD_
WHERE cardType = 'Credito';
/
-- Show only expired Cards
CREATE OR REPLACE VIEW expired_card_view AS
SELECT idCard, expirationDate, pin, CVC, cardType, idAccount
FROM CARD_
WHERE expirationDate < SYSDATE;
/
-- Show only active Credito cards
CREATE OR REPLACE VIEW active_credit_card_view AS
SELECT idCard, expirationDate, pin, CVC, cardType, idAccount
FROM CARD_
WHERE cardType = 'Credito' AND expirationDate >= SYSDATE;
/
--Show owner, cliente name, e tipo de cartao
CREATE OR REPLACE VIEW owner_client_card AS
SELECT O.idOwner, O.nif, C.nameClient, C.age, CA.cardType
FROM OWNER_ O
INNER JOIN CLIENT_ C ON O.nif = C.nif
LEFT JOIN CARD_ CA ON O.idAccount = CA.idAccount;
/
--Card Usage
CREATE OR REPLACE VIEW CardUsageStatistics AS
SELECT
    C.idCard,
    COUNT(T.idTransaction) AS TransactionCount,
    SUM(T.amount) AS TotalSpent,
    AVG(T.amount) AS AverageTransactionAmount
FROM CARD_ C
LEFT JOIN TRANSACTION_ T ON C.idCard = T.idCard
GROUP BY C.idCard
ORDER BY C.idCard;
/
-->>>>>>>>>>> OWNER
-- Show OWNERs age and job 
CREATE OR REPLACE VIEW owners_with_age_and_job_view AS
SELECT O.idOwner, O.idAccount, O.nif, O.ownership, C.age, C.jobClient
FROM OWNER_ O
INNER JOIN CLIENT_ C ON O.nif = C.nif
WHERE C.age IS NOT NULL AND C.jobClient IS NOT NULL;
/
--Show OWNERs martial status
CREATE OR REPLACE VIEW owners_with_marital_status AS
SELECT O.idOwner, O.idAccount, O.nif, O.ownership, C.maritalStatus
FROM OWNER_ O
INNER JOIN CLIENT_ C ON O.nif = C.nif
WHERE C.maritalStatus IS NOT NULL;
/
-->>>>>>>>>>> TRANSACTION
CREATE OR REPLACE VIEW ProcessedTransactions AS
SELECT
    idTransaction,
    amount,
    dateTransaction,
    idCard,
    idTransactionType,
    idAccount,
    idOwner,
    status
FROM TRANSACTION_
WHERE status = 'concluido';
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- FUnctions.
-->>>>>>>>>>>-------------------------------------------------------------------

DROP FUNCTION getTableName;
/

-->>>>>>>>>>> FUNCTION TO GET THE TABLE NAME

CREATE OR REPLACE FUNCTION getTableName(
        p_tableName VARCHAR
    ) RETURN VARCHAR
    IS
        tableFind varchar(99);
    BEGIN
        -- INSTR = INSTRING
        
        select TABLE_NAME 
        INTO tableFind
        FROM user_tables 
        WHERE INSTR(UPPER(TABLE_NAME), UPPER(p_tableName)) > 0
        ORDER BY INSTR(UPPER(TABLE_NAME), UPPER(p_tableName)) ASC
        FETCH FIRST 1 ROW ONLY;
        
        RETURN tableFind;
    END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

DROP FUNCTION getFieldName;
/

-->>>>>>>>>>> FUNCTION TO GET THE SPECIFIC FIELD NAME FROM TABLE

CREATE OR REPLACE FUNCTION getFieldName(
        p_tableName VARCHAR,
        p_fieldName VARCHAR
    ) RETURN VARCHAR
    IS
        fieldFind varchar(99);
    BEGIN
        -- INSTR = INSTRING
        
        select COLUMN_NAME 
        INTO fieldFind
        FROM ALL_TAB_COLUMNS 
        WHERE INSTR(UPPER(TABLE_NAME), UPPER(p_tableName)) > 0 
        AND INSTR(UPPER(COLUMN_NAME), UPPER(p_fieldName)) > 0
        ORDER BY INSTR(UPPER(COLUMN_NAME), UPPER(p_fieldName)) ASC
        FETCH FIRST 1 ROW ONLY;
            
        RETURN fieldFind;
    END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

DROP FUNCTION getFieldsNames;
/

-->>>>>>>>>>> FUNCTION TO GET ALL THE FIELDS NAMES FROM THE TABLE

CREATE OR REPLACE FUNCTION getFieldsNames(
        p_tableName VARCHAR
    ) RETURN VARCHAR
    IS
        fieldNames varchar(200);
    BEGIN
        SELECT LISTAGG(column_name, ', ') WITHIN GROUP (ORDER BY column_id) as fields_names
        INTO fieldNames
        FROM user_tab_columns
        WHERE table_name = p_tableName AND column_id > 1;
            
        RETURN fieldNames;
    END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

DROP FUNCTION getFieldCount;
/

-->>>>>>>>>>> FUNCTION TO GET THE NUMBER OF FIELDS IN THE TABLE

CREATE OR REPLACE FUNCTION getFieldCount(
        p_tableName VARCHAR
    ) RETURN VARCHAR
    IS
        fieldNumber NUMBER;
    BEGIN
        SELECT COUNT(*)-1 AS column_Number into fieldNumber
        FROM user_tab_columns
        WHERE table_name = p_tableName;
            
        RETURN fieldNumber;
    END;
/

-->>>>>>>>>>>-------------------------------------------------------------------
-- PROCEDURES
-->>>>>>>>>>>-------------------------------------------------------------------

-- INSERT 4 ALL

CREATE OR REPLACE PROCEDURE SP_ALL_INSERT (
    tableName VARCHAR,
    v_insert multiObjectFunction
) AS 
BEGIN
    DECLARE
        v_getTable varchar(200);
        
        v_nField NUMBER;        
        v_FieldNames VARCHAR(200);
        v_values VARCHAR(200) := '';
        
        v_insert_query VARCHAR(200);
    BEGIN
        select getTableName(tableName) INTO v_getTable FROM dual;
        
        ------------------------------------------------------------------------
        
        -- Shows the number of fiels of the table
        v_nField := getFieldCount(v_getTable);
        
        ------------------------------------------------------------------------
        
        -- shows the field of the tables
        v_FieldNames := getFieldsNames(v_getTable);
        
        ------------------------------------------------------------------------
        
        FOR i IN 1..v_nField LOOP
            IF i > 1 THEN
                IF i > v_insert.count then
                    v_values := v_values || ''', ''' || '';
                ELSE
                    v_values := v_values || ''', ''' || v_insert(i);
                END IF;
            ELSE
                v_values := v_values || v_insert(i);
            END IF;
        END LOOP;
        
        ------------------------------------------------------------------------
        
        v_insert_query := 'INSERT /*+ PARALLEL APPEND */ INTO ' || v_getTable || ' (' || v_FieldNames || ') VALUES (''' || v_values || ''')';
        
        EXECUTE IMMEDIATE v_insert_query; 
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Reccord inserted');
    END;
EXCEPTION
    WHEN OTHERS THEN
       ROLLBACK;
       DBMS_OUTPUT.PUT_LINE('Insertion Error: ' || SQLERRM);
END;
/

-->>>>>>>>>>

DECLARE
    insertValues multiObjectFunction;
BEGIN
    insertValues := multiObjectFunction('value1', 'value2', 'value3', 'value4', 'value5');

    --SP_ALL_INSERT('locat', insertValues);
END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-- UPDATE 4 ALL

CREATE OR REPLACE PROCEDURE SP_ALL_UPDATE (
    u_tableName VARCHAR,
    u_update multiObjectFunction,
    u_condition multiObjectFunction
) AS 
BEGIN
     DECLARE
         v_getTable varchar(200);
         v_getFieldUpdate varchar(200);
         v_getFieldcondition varchar(200);

         v_conditionFieldcondition varchar(200);
         
         v_insert_query VARCHAR(200);
     BEGIN
     
        select getTableName(u_tableName) INTO v_getTable FROM dual;
        select getFieldName(v_getTable, u_update(1)) INTO v_getFieldUpdate FROM dual;
        select getFieldName(v_getTable, u_condition(1)) INTO v_getFieldcondition FROM dual;
    
        ------------------------------------------------------------------------
        
        IF u_condition.COUNT >= 3 THEN
            v_conditionFieldcondition := u_condition(3);
        ELSE
            v_conditionFieldcondition := '=';
        END IF;
        
        ------------------------------------------------------------------------
        
        v_insert_query := 'UPDATE /*+ PARALLEL */' || v_getTable  || ' SET ' || v_getFieldUpdate ||' = ''' || u_update(2) ||''' WHERE ' || v_getFieldcondition ||' ' || v_conditionFieldcondition || ' ' || u_condition(2) || '';
        
        ------------------------------------------------------------------------
        
        EXECUTE IMMEDIATE v_insert_query; 
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Reccord Updated');
    END;
EXCEPTION
    WHEN OTHERS THEN
       ROLLBACK;
       DBMS_OUTPUT.PUT_LINE('Updating Error: ' || SQLERRM);
END;
/

-->>>>>>>>>>>

DECLARE
    UpdateValues multiObjectFunction;
    coditionValues multiObjectFunction;
BEGIN
    UpdateValues := multiObjectFunction('descri', 'testeAAAAAAA' );
    coditionValues := multiObjectFunction('idAccountType', '3', '=');    
    
    --SP_ALL_UPDATE('ACCOUNTTYP', UpdateValues, coditionValues);
END;
/

-->>>>>>>>>>>-------------------------------------------------------------------

-- DELETE 4 ALL

CREATE OR REPLACE PROCEDURE SP_ALL_DELETE (
    u_tableName VARCHAR,
    u_condition multiObjectFunction
) AS 
BEGIN
     DECLARE
         v_getTable varchar(200);
         v_getFieldcondition varchar(200);
         
          v_conditionFieldcondition varchar(200);
         
         v_insert_query VARCHAR(200);
     BEGIN
        select getTableName(u_tableName) INTO v_getTable FROM dual;
    select getFieldName(v_getTable, u_condition(1)) INTO v_getFieldcondition FROM dual;
    
        ------------------------------------------------------------------------
        
        IF u_condition.COUNT >= 3 THEN
            v_conditionFieldcondition := u_condition(3);
        ELSE
            v_conditionFieldcondition := '=';
        END IF;
        
        ------------------------------------------------------------------------
        
        v_insert_query := 'DELETE /*+ PARALLEL */ FROM ' || v_getTable  || ' WHERE ' || v_getFieldcondition ||' '|| v_conditionFieldcondition ||' ''' || u_condition(2) || '''';

        ------------------------------------------------------------------------
        
        EXECUTE IMMEDIATE v_insert_query; 
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Reccord Deleted');
    END;
EXCEPTION
    WHEN OTHERS THEN
       ROLLBACK;
       DBMS_OUTPUT.PUT_LINE('Deleting Error: ' || SQLERRM);
END;
/

-->>>>>>>>>>>

DECLARE
    coditionValues multiObjectFunction;
BEGIN
    coditionValues := multiObjectFunction('IDACCO', '6', '=');    

    --SP_ALL_DELETE('ACCOUNTTYP', coditionValues);
END;
/
